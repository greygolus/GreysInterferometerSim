<!DOCTYPE html>
<!--
  Wave Interference Simulator — WebGL edition
  GPU fragment shader replaces the per-pixel CPU loop.
  All UI, controls, presets and interaction are unchanged.
-->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Wave Interference Simulator</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Syne:wght@800&display=swap');
    :root {
      --bg:     #040709;
      --panel:  #07101c;
      --border: #0d1a2c;
      --dim:    #1e2e42;
      --text:   #7090b0;
      --bright: #a0c0e0;
      --accent: #00e5ff;
      --red:    #ff3d7f;
      --green:  #7fff00;
      --amber:  #ffaa00;
    }
    *, *::before, *::after {
      margin: 0; padding: 0; box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }
    html, body { width: 100%; height: 100%; overflow: hidden; background: var(--bg); }
    body {
      display: flex; flex-direction: column;
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px; color: var(--text);
    }
    #main     { flex: 1; min-height: 0; display: flex; flex-direction: column; overflow: hidden; }
    #canvases { flex: 1; min-height: 0; display: flex; flex-direction: column; overflow: hidden; }
    @media (min-width: 700px) {
      #main       { flex-direction: row; }
      #ctrl-panel { width: 268px; border-top: none !important; border-left: 1px solid var(--border); }
    }
    #hdr {
      flex-shrink: 0; height: 36px;
      display: flex; align-items: center; justify-content: space-between;
      padding: 0 8px; gap: 5px;
      background: var(--panel); border-bottom: 1px solid var(--border);
    }
    #hdr h1 {
      font-family: 'Syne', sans-serif; font-size: 13px; font-weight: 800;
      color: var(--accent); letter-spacing: -0.3px; white-space: nowrap;
    }
    .hdr-btns { display: flex; gap: 3px; flex-shrink: 0; flex-wrap: wrap; justify-content: flex-end; }
    .btn {
      font-family: 'JetBrains Mono', monospace; font-size: 9px;
      padding: 3px 7px; border-radius: 3px; cursor: pointer;
      background: var(--border); border: 1px solid var(--dim);
      color: var(--text); white-space: nowrap; line-height: 1;
      transition: transform 0.1s;
    }
    .btn:active         { transform: scale(0.92); }
    .btn.on             { background: var(--accent); color: #000; border-color: var(--accent); }
    .btn.danger         { border-color: var(--red); }
    .btn.danger:active  { background: var(--red); color: #000; }
    .btn.warn           { border-color: var(--amber); }
    .btn.warn.on        { background: var(--amber); color: #000; }
    #cwrap {
      flex: 1; min-height: 0; position: relative;
      background: #000; overflow: hidden;
    }
    #cgl { display: block; width: 100%; height: 100%; position: absolute; top:0; left:0; }
    #c   { display: block; width: 100%; height: 100%; position: absolute; top:0; left:0; touch-action: none; }
    #cursor-hud {
      position: absolute; top: 5px; left: 7px;
      font-size: 8px; color: rgba(255,255,255,0.22);
      pointer-events: none; line-height: 1.7; z-index: 2;
    }
    #fps {
      position: absolute; top: 5px; right: 7px;
      font-size: 8px; color: rgba(255,255,255,0.14); pointer-events: none; z-index: 2;
    }
    #pwrap {
      flex-shrink: 0; height: 88px; background: #000;
      border-top: 1px solid var(--border);
      position: relative; overflow: hidden;
    }
    #pc { display: block; width: 100%; height: 100%; }
    #plabel {
      position: absolute; top: 3px; right: 5px;
      font-size: 7px; color: rgba(255,255,255,0.18); pointer-events: none;
    }
    #ctrl-panel {
      flex-shrink: 0; background: var(--panel);
      border-top: 1px solid var(--border);
      display: flex; flex-direction: column; overflow: hidden;
    }
    #tab-bar {
      display: flex; flex-shrink: 0;
      border-bottom: 1px solid var(--border); background: var(--bg);
    }
    .tab {
      flex: 1; padding: 5px 2px; text-align: center;
      font-size: 9px; cursor: pointer; color: var(--dim);
      border-bottom: 2px solid transparent; white-space: nowrap;
    }
    .tab.on { color: var(--accent); border-bottom-color: var(--accent); }
    #tab-content { flex: 1; min-height: 0; overflow: hidden; }
    .tpane {
      display: none; width: 100%; height: 100%;
      padding: 7px 8px; overflow: hidden;
      flex-direction: column; gap: 4px;
    }
    .tpane.on { display: flex; }
    .row  { display: flex; align-items: center; gap: 5px; min-height: 19px; }
    .lbl  { font-size: 8px; color: var(--dim); flex-shrink: 0; width: 62px; }
    .val  { font-size: 8px; color: var(--bright); min-width: 38px; text-align: right; flex-shrink: 0; }
    input[type="range"] {
      flex: 1; -webkit-appearance: none; height: 3px;
      background: var(--dim); border-radius: 2px; outline: none; min-width: 0;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none; width: 14px; height: 14px;
      border-radius: 50%; background: var(--accent); cursor: pointer;
      border: 2px solid var(--bg); box-shadow: 0 0 4px var(--accent);
    }
    select {
      flex: 1; background: var(--border); border: 1px solid var(--dim);
      color: var(--text); font-family: 'JetBrains Mono', monospace;
      font-size: 9px; padding: 3px 4px; border-radius: 3px;
      outline: none; min-width: 0;
    }
    .trow { display: flex; gap: 3px; flex-wrap: wrap; }
    .tog {
      font-family: 'JetBrains Mono', monospace; font-size: 8px;
      padding: 3px 6px; border-radius: 3px; cursor: pointer;
      background: var(--border); border: 1px solid var(--dim);
      color: var(--dim); white-space: nowrap; transition: all 0.1s;
    }
    .tog.on { background: rgba(0,229,255,0.1); border-color: var(--accent); color: var(--accent); }
    .div   { height: 1px; background: var(--border); flex-shrink: 0; margin: 1px 0; }
    .swatch { width: 10px; height: 10px; border-radius: 2px; flex-shrink: 0; border: 1px solid rgba(255,255,255,0.12); }
    .itabs { display: flex; gap: 3px; flex-wrap: wrap; }
    .itab  {
      padding: 3px 7px; border-radius: 3px; font-size: 9px;
      font-family: 'JetBrains Mono', monospace;
      cursor: pointer; border: 1px solid; background: var(--border); color: var(--dim);
    }
    .itab.on   { color: #000; font-weight: 700; }
    .itab.off  { opacity: 0.3; }
    .dgrid { display: grid; grid-template-columns: 1fr 1fr; gap: 3px; }
    .dtile { background: var(--border); border-radius: 3px; padding: 3px 5px; display: flex; flex-direction: column; }
    .dtile-lbl { font-size: 7px; color: var(--dim); text-transform: uppercase; letter-spacing: 0.4px; }
    .dtile-val { font-size: 10px; color: var(--accent); font-weight: 700; line-height: 1.3; }
    .dtile-unit { font-size: 6px; color: var(--dim); }
    .dtile.g .dtile-val { color: var(--green); }
    .dtile.y .dtile-val { color: var(--amber); }
    .dtile.p .dtile-val { color: #cc99ff; }
    .pgrid { display: grid; grid-template-columns: repeat(2,1fr); gap: 3px; }
    .slit-card {
      background: var(--border); border-radius: 3px;
      padding: 4px 5px; margin: 2px 0;
      display: flex; flex-direction: column; gap: 3px;
    }
    .slit-card-hdr { display: flex; align-items: center; justify-content: space-between; }
  </style>
</head>
<body>

<header id="hdr">
  <h1>&#9675; WAVE INTERFERENCE</h1>
  <div class="hdr-btns">
    <button class="btn"        id="b-pause">&#9208; Pause</button>
    <button class="btn"        id="b-freeze">&#10052; Freeze</button>
    <button class="btn"        id="b-addpt">&#65291; Point</button>
    <button class="btn"        id="b-addpw">&#65291; Plane</button>
    <button class="btn warn"   id="b-addwall">&#65291; Wall</button>
    <button class="btn danger" id="b-clear">&#10005; Clear</button>
  </div>
</header>

<div id="main">
  <div id="canvases">
    <div id="cwrap">
      <canvas id="cgl"></canvas>
      <canvas id="c"></canvas>
      <div id="cursor-hud">move mouse over pattern</div>
      <div id="fps"></div>
    </div>
    <div id="pwrap">
      <canvas id="pc"></canvas>
      <div id="plabel"></div>
    </div>
  </div>

  <div id="ctrl-panel">
    <div id="tab-bar">
      <div class="tab on"  data-t="scene">Scene</div>
      <div class="tab"     data-t="display">Display</div>
      <div class="tab"     data-t="analysis">Analysis</div>
      <div class="tab"     data-t="presets">Presets</div>
    </div>
    <div id="tab-content">

      <div class="tpane on" id="pane-scene">
        <div class="itabs" id="src-tabs"></div>
        <div id="src-ctrl"></div>
        <div class="div"></div>
        <div class="itabs" id="wall-tabs"></div>
        <div id="wall-ctrl"></div>
        <div class="div"></div>
        <div class="trow">
          <button class="tog"    id="t-snap">&#8862; Snap</button>
          <button class="tog on" id="t-labels">Labels</button>
        </div>
        <div class="row">
          <span class="lbl">Snap size</span>
          <input type="range" id="sl-snap" min="10" max="80" step="5" value="30">
          <span class="val" id="vl-snap">30px</span>
        </div>
      </div>

      <div class="tpane" id="pane-display">
        <div class="row"><span class="lbl">Color map</span>
          <select id="sel-cmap">
            <option value="spectral" selected>Spectral</option>
            <option value="mono">Monochrome</option>
            <option value="laser">Laser green</option>
            <option value="red">Laser red</option>
            <option value="blue">Laser blue</option>
            <option value="false">False color</option>
            <option value="spectrum">Spectrum</option>
            <option value="fire">Fire</option>
            <option value="ice">Ice</option>
            <option value="gold">Gold</option>
          </select></div>
        <div class="row"><span class="lbl">Fringes</span>
          <select id="sel-style">
            <option value="sharp">Sharp (cosn)</option>
            <option value="cos">Cosine</option>
            <option value="binary">Binary</option>
            <option value="grating">Grating</option>
            <option value="gauss">Gaussian</option>
          </select></div>
        <div class="row"><span class="lbl">Sharpness</span><input type="range" id="sl-sharp" min="1" max="24" step=".5" value="6"><span class="val" id="vl-sharp">6.0</span></div>
        <div class="row"><span class="lbl">Wavelength</span><input type="range" id="sl-wl" min="8" max="200" step="1" value="52"><span class="val" id="vl-wl">52px</span></div>
        <div class="row"><span class="lbl">Brightness</span><input type="range" id="sl-bright" min=".1" max="3" step=".05" value="1"><span class="val" id="vl-bright">1.00</span></div>
        <div class="row"><span class="lbl">Background</span><input type="range" id="sl-bg" min="0" max=".6" step=".01" value=".05"><span class="val" id="vl-bg">0.05</span></div>
        <div class="row"><span class="lbl">Gamma</span><input type="range" id="sl-gamma" min=".3" max="3" step=".05" value="1"><span class="val" id="vl-gamma">1.00</span></div>
        <div class="row"><span class="lbl">Speed</span><input type="range" id="sl-speed" min="0" max="4" step=".05" value=".8"><span class="val" id="vl-speed">0.80</span></div>
        <div class="row"><span class="lbl">Damping</span><input type="range" id="sl-damp" min="0" max=".012" step=".0002" value="0"><span class="val" id="vl-damp">0.000</span></div>
        <div class="div"></div>
        <div class="row"><span class="lbl">Mode</span>
          <select id="sel-mode">
            <option value="phasor">Phasor (coherent)</option>
            <option value="incoherent">Incoherent sum</option>
            <option value="product">Product</option>
            <option value="max">Envelope max</option>
          </select></div>
        <div class="div"></div>
        <div class="trow">
          <button class="tog on" id="t-grid">Grid</button>
          <button class="tog"    id="t-rings">Wavefronts</button>
          <button class="tog"    id="t-nodes">Nulls</button>
          <button class="tog"    id="t-invert">Invert</button>
        </div>
      </div>

      <div class="tpane" id="pane-analysis">
        <div class="dgrid">
          <div class="dtile">  <span class="dtile-lbl">Fringe spacing</span><span class="dtile-val" id="d-fs">-</span><span class="dtile-unit">pixels</span></div>
          <div class="dtile g"><span class="dtile-lbl">Visibility V</span>  <span class="dtile-val" id="d-vis">-</span><span class="dtile-unit">(Imax-Imin)/(Imax+Imin)</span></div>
          <div class="dtile y"><span class="dtile-lbl">Path diff dL</span>  <span class="dtile-val" id="d-opd">-</span><span class="dtile-unit">px @ cursor</span></div>
          <div class="dtile p"><span class="dtile-lbl">Phase diff dp</span> <span class="dtile-val" id="d-phi">-</span><span class="dtile-unit">deg @ cursor</span></div>
          <div class="dtile">  <span class="dtile-lbl">Intensity</span>     <span class="dtile-val" id="d-I">-</span>  <span class="dtile-unit">0-1 @ cursor</span></div>
          <div class="dtile g"><span class="dtile-lbl">Fringe order</span>  <span class="dtile-val" id="d-ord">-</span><span class="dtile-unit">dL/lam @ cursor</span></div>
          <div class="dtile y"><span class="dtile-lbl">Coh. length</span>   <span class="dtile-val" id="d-lc">-</span> <span class="dtile-unit">pixels</span></div>
          <div class="dtile p"><span class="dtile-lbl">Sources</span>        <span class="dtile-val" id="d-n">-</span>  <span class="dtile-unit">active</span></div>
        </div>
        <div class="div"></div>
        <div class="trow" id="prof-modes">
          <button class="tog on" data-m="horiz">H-slice</button>
          <button class="tog"    data-m="vert">V-slice</button>
          <button class="tog"    data-m="diag">Diagonal</button>
          <button class="tog"    data-m="radial">Radial</button>
          <button class="tog"    data-m="circ">Circular</button>
        </div>
        <div class="row">
          <span class="lbl">Position</span>
          <input type="range" id="sl-ppos" min="0" max="1" step=".005" value=".5">
          <span class="val" id="vl-ppos">50%</span>
        </div>
        <div class="row"><span class="lbl">Color</span>
          <select id="sel-pcol">
            <option value="cyan">Cyan</option>
            <option value="green">Green</option>
            <option value="white">White</option>
            <option value="red">Red</option>
          </select></div>
        <div class="trow">
          <button class="tog on" id="t-pline">Scan line</button>
          <button class="tog on" id="t-pfill">Fill</button>
          <button class="tog"    id="t-pgrid">Grid lines</button>
        </div>
      </div>

      <div class="tpane" id="pane-presets">
        <div class="pgrid" id="pgrid"></div>
      </div>

    </div>
  </div>
</div>

<script>
'use strict';

// ─── LIGHT SOURCE DATABASE ────────────────────────────────────
const LIGHT_SOURCES = [
  { id:'custom',       name:'Custom',             coh:1.00, wlPx:52, wlNm:550, desc:'Fully adjustable - use the Wavelength slider' },
  { id:'laser_red',    name:'Red laser 633nm',    coh:1.00, wlPx:80, wlNm:633, desc:'HeNe laser - perfectly monochromatic, very long coherence' },
  { id:'laser_green',  name:'Green laser 532nm',  coh:1.00, wlPx:65, wlNm:532, desc:'DPSS laser - sharp fringes, long coherence length' },
  { id:'laser_blue',   name:'Blue laser 445nm',   coh:1.00, wlPx:54, wlNm:445, desc:'Diode laser - monochromatic blue' },
  { id:'laser_violet', name:'Violet laser 405nm', coh:1.00, wlPx:48, wlNm:405, desc:'Short-wavelength diode - tightest fringes' },
  { id:'mercury_546',  name:'Mercury 546nm',      coh:0.85, wlPx:66, wlNm:546, desc:'Hg green line - nearly monochromatic, classic spectroscopy' },
  { id:'mercury_436',  name:'Mercury 436nm',      coh:0.80, wlPx:52, wlNm:436, desc:'Hg blue-violet line - narrow spectral line' },
  { id:'sodium_589',   name:'Sodium lamp 589nm',  coh:0.60, wlPx:73, wlNm:589, desc:'Na D-lines - amber yellow, moderate coherence' },
  { id:'led_red',      name:'Red LED 625nm',      coh:0.35, wlPx:78, wlNm:625, desc:'Narrowband red LED - partial coherence' },
  { id:'led_green',    name:'Green LED 525nm',    coh:0.30, wlPx:64, wlNm:525, desc:'Narrowband green LED - partial coherence' },
  { id:'led_white',    name:'White LED',          coh:0.12, wlPx:55, wlNm:550, desc:'Broad spectrum - fringes wash out quickly' },
  { id:'fluoro',       name:'Fluorescent tube',   coh:0.08, wlPx:58, wlNm:550, desc:'Mercury phosphor mix - poor coherence' },
  { id:'incandescent', name:'Incandescent bulb',  coh:0.04, wlPx:62, wlNm:600, desc:'Blackbody spectrum - almost no fringes' },
  { id:'sunlight',     name:'Sunlight',           coh:0.02, wlPx:56, wlNm:550, desc:'Broadest spectrum - coherence length ~1 um' },
];
const getLightSource = (src) => LIGHT_SOURCES.find(l => l.id === src.lightSrc) || LIGHT_SOURCES[0];

// ─── SPECTRAL COLOUR (CPU side, for overlays/profile) ─────────
function wavelengthToRGB(nm) {
  let r=0,g=0,b=0;
  if      (nm>=380&&nm<440){r=(440-nm)/60;b=1;}
  else if (nm>=440&&nm<490){g=(nm-440)/50;b=1;}
  else if (nm>=490&&nm<510){g=1;b=(510-nm)/20;}
  else if (nm>=510&&nm<580){r=(nm-510)/70;g=1;}
  else if (nm>=580&&nm<645){r=1;g=(645-nm)/65;}
  else if (nm>=645&&nm<=780){r=1;}
  let s=1;
  if      (nm>=380&&nm<420) s=0.3+0.7*(nm-380)/40;
  else if (nm>700&&nm<=780) s=0.3+0.7*(780-nm)/80;
  const gm=0.8;
  return [r>0?Math.pow(r*s,gm):0, g>0?Math.pow(g*s,gm):0, b>0?Math.pow(b*s,gm):0];
}
function srcRGB(src) {
  const ls=getLightSource(src);
  if(ls.id==='custom'){const h=src.color.replace('#','');return[parseInt(h.slice(0,2),16)/255,parseInt(h.slice(2,4),16)/255,parseInt(h.slice(4,6),16)/255];}
  return wavelengthToRGB(ls.wlNm);
}
function srcCSS(src,boost=60){const[r,g,b]=srcRGB(src);return`rgb(${Math.min(255,(r*255+boost))|0},${Math.min(255,(g*255+boost))|0},${Math.min(255,(b*255+boost))|0})`;}

// ─── STATE ────────────────────────────────────────────────────
const glCanvas  = document.getElementById('cgl');
const canvas    = document.getElementById('c');
const ctx       = canvas.getContext('2d');
const pcanvas   = document.getElementById('pc');
const pctx      = pcanvas.getContext('2d');

let W=0,H=0,PW=0,PH=0;
let simTime=0, paused=false, frozen=false;
let lastFrame=performance.now(), fpsEst=60, frameCount=0;
const TAU=Math.PI*2;

let colorMap='spectral', fringeStyle='sharp', sharpness=6, wavelength=52;
let brightness=1, bgLevel=0.05, gamma=1, speed=0.8, damping=0;
let superpos='phasor';
let showLabels=true, showGrid=true, showRings=false, showNulls=false, invertImg=false;
let snapOn=false, snapSz=30;
let profMode='horiz', profPos=0.5, profColor='cyan';
let showProfLine=true, showProfFill=true, showProfGrid=false;
let curX=0, curY=0, curOnCanvas=false;

const SRC_COLORS=['#00e5ff','#ff3d7f','#7fff00','#ffaa00','#cc66ff','#ff8800'];
const SRC_NAMES =['S1','S2','S3','S4','S5','S6'];
let sources=[], selSrc=0;
let walls=[], selWall=0, editWalls=false;
let huygSrcs=[];

// ─── FACTORIES ────────────────────────────────────────────────
function mkPoint(x,y,i){return{type:'point',x,y,amp:1,phase:0,enabled:true,waveform:'sine',lightSrc:'custom',color:SRC_COLORS[i%6],name:SRC_NAMES[i%6]};}
function mkPlane(i){return{type:'plane',cx:W*0.5,cy:H*0.5,angle:0,side:'right',amp:1,phase:0,enabled:true,waveform:'sine',lightSrc:'custom',color:SRC_COLORS[i%6],name:SRC_NAMES[i%6]};}
function mkWall(){return{xFrac:0.5,angle:0,thick:4,enabled:true,name:'W'+(walls.length+1),slits:[{pos:0.40,width:20},{pos:0.60,width:20}]};}

// ─── CPU WAVE HELPERS (for analysis + profile strip) ──────────
function osc(form,phi){
  switch(form){
    case 'square':return Math.sin(phi)>=0?1:-1;
    case 'saw':{const p=((phi%TAU)+TAU)%TAU;return p/Math.PI-1;}
    case 'tri':{const p=((phi%TAU)+TAU)%TAU;return p<Math.PI?(p/Math.PI)*2-1:1-(p-Math.PI)/Math.PI*2;}
    default:return Math.sin(phi);
  }
}
function fringe(v,style,sh){
  switch(style){
    case 'cos':return Math.cos(v*Math.PI)*0.5+0.5;
    case 'sharp':{const c=Math.cos(v*Math.PI)*0.5+0.5;return Math.pow(c,sh);}
    case 'binary':return Math.cos(v*Math.PI)>0?1:0;
    case 'grating':{const s=Math.sin(v*Math.PI);return Math.pow(s*s,sh*0.5);}
    case 'gauss':{const w=((v%2)+2)%2-1;return Math.exp(-w*w*sh*2);}
    default:return Math.cos(v*Math.PI)*0.5+0.5;
  }
}
function wallNorm(wall,x,y){const a=wall.angle*Math.PI/180;return(x-wall.xFrac*W)*Math.cos(a)+(y-H/2)*Math.sin(a);}
function wallProj(wall,x,y){const a=wall.angle*Math.PI/180,lx=-Math.sin(a),ly=Math.cos(a),L=Math.hypot(W,H);return((x-wall.xFrac*W)*lx+(y-H/2)*ly+L/2)/L;}
function inSlit(wall,frac){const L=Math.hypot(W,H);for(const sl of wall.slits){const hw=(sl.width/2)/L;if(frac>=sl.pos-hw&&frac<=sl.pos+hw)return true;}return false;}
function isBlocked(x,y){for(const w of walls){if(!w.enabled)continue;if(Math.abs(wallNorm(w,x,y))>w.thick/2)continue;if(!inSlit(w,wallProj(w,x,y)))return true;}return false;}
function isPathBlocked(sx,sy,px,py){
  for(const w of walls){
    if(!w.enabled)continue;
    const ss=wallNorm(w,sx,sy),ps=wallNorm(w,px,py);
    if(ss*ps>=0)continue;
    const a=w.angle*Math.PI/180,nx=Math.cos(a),ny=Math.sin(a);
    const d=(px-sx)*nx+(py-sy)*ny;
    if(Math.abs(d)<1e-6)continue;
    const t=((w.xFrac*W-sx)*nx+(H/2-sy)*ny)/d;
    if(t<0||t>1)continue;
    if(!inSlit(w,wallProj(w,sx+t*(px-sx),sy+t*(py-sy))))return true;
  }
  return false;
}
function srcPos(s){return(s.type==='point'||s.type==='huygen')?{x:s.x,y:s.y}:{x:s.cx,y:s.cy};}
function pathLen(s,x,y){if(s.type==='plane'){const a=s.angle*Math.PI/180;return Math.abs((x-s.cx)*Math.cos(a)+(y-s.cy)*Math.sin(a));}return Math.hypot(x-s.x,y-s.y)+1e-5;}
function srcField(s,x,y,k,omega,t){
  if(!s.enabled)return 0;
  const damp=r=>damping>0?Math.exp(-r*damping):1;
  if(s.type==='point'||s.type==='huygen'){const r=Math.hypot(x-s.x,y-s.y)+1e-5;return s.amp*damp(r)*osc(s.waveform,k*r-omega*t*60+s.phase*Math.PI/180);}
  if(s.type==='plane'){const a=s.angle*Math.PI/180,nx=Math.cos(a),ny=Math.sin(a),d=(x-s.cx)*nx+(y-s.cy)*ny;if(s.side==='right'&&d<0)return 0;if(s.side==='left'&&d>0)return 0;const r=Math.abs(d)+1e-5;return s.amp*damp(r)*osc(s.waveform,k*r-omega*t*60+s.phase*Math.PI/180);}
  return 0;
}
function wavePhase(s,x,y,k,omega,t){
  if(s.type==='point')return k*(Math.hypot(x-s.x,y-s.y)+1e-5)-omega*t*60+s.phase*Math.PI/180;
  if(s.type==='plane'){const a=s.angle*Math.PI/180;return k*(Math.abs((x-s.cx)*Math.cos(a)+(y-s.cy)*Math.sin(a))+1e-5)-omega*t*60+s.phase*Math.PI/180;}
  return 0;
}
function buildHuygens(eSrc,k,omega){
  huygSrcs=[];
  for(const w of walls){
    if(!w.enabled)continue;
    const a=w.angle*Math.PI/180,wx=w.xFrac*W,L=Math.hypot(W,H),lx=-Math.sin(a),ly=Math.cos(a);
    const avgSide=eSrc.reduce((s,src)=>s+wallNorm(w,srcPos(src).x,srcPos(src).y),0);
    const fwd=avgSide<0?1:-1;
    for(const sl of w.slits){
      const n=Math.max(3,Math.round(sl.width/8)),centOff=(sl.pos-0.5)*L;
      for(let p=0;p<n;p++){
        const off=n===1?0:(p/(n-1)-0.5)*sl.width;
        const hx=wx+lx*(centOff+off),hy=H/2+ly*(centOff+off);
        let amp=0,waveform='sine',lightSrc='custom',color='#ffffff',phase=0;
        for(const s of eSrc){
          const f=srcField(s,hx,hy,k,omega,simTime);
          if(Math.abs(f)>Math.abs(amp)){amp=s.amp*0.7;waveform=s.waveform;lightSrc=s.lightSrc;color=s.color;}
          phase+=wavePhase(s,hx,hy,k,omega,simTime);
        }
        phase/=Math.max(1,eSrc.length);
        huygSrcs.push({type:'huygen',x:hx,y:hy,amp:amp/n,phase:phase*(180/Math.PI),waveform,lightSrc,color,enabled:true,wallRef:w,fwd});
      }
    }
  }
}
function fieldAt(x,y,eSrc,k,omega,t){
  if(isBlocked(x,y))return 0;
  let amp=0,n=0;
  for(const s of eSrc){const p=srcPos(s);if(isPathBlocked(p.x,p.y,x,y))continue;amp+=srcField(s,x,y,k,omega,t);n++;}
  for(const hs of huygSrcs){if(wallNorm(hs.wallRef,x,y)*hs.fwd<0)continue;amp+=srcField(hs,x,y,k,omega,t);n++;}
  const N=Math.max(1,n);
  if(superpos==='phasor'){
    const active=[...eSrc.filter(s=>{const p=srcPos(s);return!isPathBlocked(p.x,p.y,x,y);}),...huygSrcs];
    let maxOPD=0;
    if(active.length>=2){const r0=pathLen(active[0],x,y);for(let i=1;i<Math.min(active.length,4);i++)maxOPD=Math.max(maxOPD,Math.abs(r0-pathLen(active[i],x,y)));}
    const ls=getLightSource(eSrc[0]||{lightSrc:'custom'});
    const Lc=(wavelength/(1-ls.coh+0.001))*0.5;
    const env=ls.coh>=1?1:Math.exp(-((maxOPD/Lc)*(maxOPD/Lc)));
    const I=bgLevel+(1-bgLevel)*(0.5*(1-env)+fringe(amp/N,fringeStyle,sharpness)*env);
    return Math.max(0,Math.min(1,I*brightness));
  }
  return Math.max(0,Math.min(1,(bgLevel+(1-bgLevel)*fringe(amp/N,fringeStyle,sharpness))*brightness));
}

// ─── WEBGL SETUP ──────────────────────────────────────────────
// Shader is compiled once per unique (nSrc, nWall) combination.
// All loop bounds are literal constants baked into the GLSL source
// so the code is fully GLSL ES 1.0 compliant.
// type encoding: 0=point, 1=plane, 2=huygens
let gl, glProg, glUniforms={}, glCompiledKey='';
const MAX_WALLS=4;

const VERT_SRC=`attribute vec2 a_pos;void main(){gl_Position=vec4(a_pos,0.0,1.0);}`;

function buildFragSrc(NS, NW) {
  // GLSL ES 1.0 strict: NO non-constant array indexing anywhere.
  // Solution: inline every wall and source operation using JS template generation.
  // No function takes an index parameter. Everything is per-literal-constant.

  // Per-wall helper snippets — each wall index is a JS literal baked into GLSL
  // wNorm_N(p)  : signed distance from wall N (normal direction)
  // wProj_N(p)  : fractional position along wall N
  // wSolid_N(p) : bool — wall N blocks p (false if open/slit passes)
  // wCuts_N(s,p): bool — wall N cuts segment s→p
  function wallSnippets(wi, sc) {
    // sc = JS string for the slit-count component: 'u_sc.x' etc
    const scComp = ['u_sc.x','u_sc.y','u_sc.z','u_sc.w'][wi];
    // slit indices for this wall: wi*4 .. wi*4+3
    const slitChecks = Array.from({length:4}, (_,si) => {
      const idx = wi*4+si;
      return `if(float(${si})<${scComp}){vec4 sl${idx}=u_slitData[${idx}];if(frac>=sl${idx}.x-sl${idx}.y&&frac<=sl${idx}.x+sl${idx}.y)return false;}`;
    }).join('');
    return `
float wNorm${wi}(vec2 p){vec4 w=u_wallA[${wi}];float wx=w.x*u_res.x,a=w.y;return(p.x-wx)*cos(a)+(p.y-u_res.y*0.5)*sin(a);}
float wProj${wi}(vec2 p){vec4 w=u_wallA[${wi}];float wx=w.x*u_res.x,a=w.y,lx=-sin(a),ly=cos(a),L=length(u_res);return((p.x-wx)*lx+(p.y-u_res.y*0.5)*ly+L*0.5)/L;}
bool wSolid${wi}(vec2 p){vec4 w=u_wallA[${wi}];if(w.w<0.5)return false;if(abs(wNorm${wi}(p))>w.z*0.5)return false;float frac=wProj${wi}(p);${slitChecks}return true;}
bool wCuts${wi}(vec2 s,vec2 p){vec4 w=u_wallA[${wi}];if(w.w<0.5)return false;float ss=wNorm${wi}(s),ps=wNorm${wi}(p);if(ss*ps>=0.0)return false;float a=w.y;vec2 n=vec2(cos(a),sin(a));float d=dot(p-s,n);if(abs(d)<1e-6)return false;float wx=w.x*u_res.x;float t=dot(vec2(wx,u_res.y*0.5)-s,n)/d;if(t<0.0||t>1.0)return false;float frac=wProj${wi}(s+t*(p-s));${slitChecks}return false;}`;
  }

  const allWallSnippets = Array.from({length:NW}, (_,wi) => wallSnippets(wi)).join('\n');
  const isBlockedBody = Array.from({length:NW}, (_,wi) => `if(wSolid${wi}(p))return true;`).join('');
  const pathBlockedBody = Array.from({length:NW}, (_,wi) => `if(wCuts${wi}(s,p))return true;`).join('');

  // Per-source active check — inlined per source index, no function parameter indexing
  function srcActiveInline(i) {
    // type stored in u_srcA[i].x: 0=point,1=plane,2=huygens
    // For huygens: check forward side of its wall (wall index in u_srcD[i].x)
    const wallNormForHuyg = Array.from({length:NW}, (_,wi) =>
      `if(abs(u_srcD[${i}].x-${wi}.0)<0.5)wn${i}=wNorm${wi}(p);`
    ).join('');
    return `float act${i};{
  if(u_srcA[${i}].x>1.5){float wn${i}=0.0;${wallNormForHuyg}act${i}=wn${i}*u_srcC[${i}].w>=0.0?1.0:0.0;}
  else{bool blk${i}=false;${Array.from({length:NW},(_,wi)=>`if(wCuts${wi}(u_srcA[${i}].yz,p))blk${i}=true;`).join('')}act${i}=blk${i}?0.0:1.0;}
}`;
  }

  // Per-source wave contribution — fully inlined, no index param
  function srcFInline(i, kvar, omvar) {
    return `float f${i};{vec4 sA=u_srcA[${i}],sB=u_srcB[${i}];float tp=sA.x,ph=sB.x,ang=sB.y,side=sB.z,dmp=1.0;
  if(tp<0.5||tp>1.5){float r=length(p-sA.yz)+1e-5;if(u_damp>0.0)dmp=exp(-r*u_damp);f${i}=sA.w*dmp*sin(${kvar}*r-${omvar}*u_time*60.0+ph);}
  else{vec2 nv=vec2(cos(ang),sin(ang));float d=dot(p-sA.yz,nv);float r=abs(d)+1e-5;if(u_damp>0.0)dmp=exp(-r*u_damp);float sv=(side<-0.5&&d<0.0)?0.0:(side>0.5&&d>0.0)?0.0:1.0;f${i}=sA.w*dmp*sin(${kvar}*r-${omvar}*u_time*60.0+ph)*sv;}
}`;
  }

  function pLenInline(i) {
    return `float pl${i};{vec4 sA=u_srcA[${i}],sB=u_srcB[${i}];if(sA.x>0.5&&sA.x<1.5){vec2 nv=vec2(cos(sB.y),sin(sB.y));pl${i}=abs(dot(p-sA.yz,nv));}else pl${i}=length(p-sA.yz)+1e-5;}`;
  }

  // Spectral main body
  const spectralBody = Array.from({length:NS}, (_,i) => `
  ${srcActiveInline(i)}
  float ki${i}=TAU/u_srcB[${i}].w;
  ${srcFInline(i, `ki${i}`, `ki${i}`)}
  float Ii${i}=clamp((u_bg+(1.0-u_bg)*fringeF(f${i}*act${i}))*u_bright*u_srcA[${i}].w,0.0,1.0);
  col+=u_srcC[${i}].rgb*Ii${i}*act${i};`).join('');

  // Superposition main body
  const superBody = Array.from({length:NS}, (_,i) => `
  ${srcActiveInline(i)}
  ${srcFInline(i, 'k', 'om')}
  amp+=f${i}*act${i}; nAct+=act${i};`).join('');

  // OPD coherence body
  const opdBody = Array.from({length:NS}, (_,i) => `
  if(u_srcA[${i}].x<1.5){bool oblk${i}=false;${Array.from({length:NW},(_,wi)=>`if(wCuts${wi}(u_srcA[${i}].yz,p))oblk${i}=true;`).join('')}if(!oblk${i}){${pLenInline(i)}if(got0<0.5){r0=pl${i};got0=1.0;}else maxOPD=max(maxOPD,abs(r0-pl${i}));}}`).join('');

  return `precision highp float;
uniform vec2  u_res;
uniform float u_time,u_wl,u_bright,u_bg,u_gamma,u_damp,u_sharp;
uniform float u_cmap,u_fringe,u_spos,u_inv,u_coh;
uniform vec4  u_srcA[${NS}],u_srcB[${NS}],u_srcC[${NS}],u_srcD[${NS}];
uniform vec4  u_wallA[${NW}];
uniform vec4  u_slitData[${NW*4}];
uniform vec4  u_sc;
const float PI=3.14159265358979,TAU=6.28318530717959;
${allWallSnippets}
bool isBlocked(vec2 p){${isBlockedBody}return false;}
bool pathBlocked(vec2 s,vec2 p){${pathBlockedBody}return false;}
float fringeF(float v){
  if(u_fringe<0.5){float c=cos(v*PI)*0.5+0.5;return pow(c,u_sharp);}
  if(u_fringe<1.5)return cos(v*PI)*0.5+0.5;
  if(u_fringe<2.5)return cos(v*PI)>0.0?1.0:0.0;
  if(u_fringe<3.5){float s2=sin(v*PI);return pow(s2*s2,u_sharp*0.5);}
  float w2=mod(mod(v,2.0)+2.0,2.0)-1.0;return exp(-w2*w2*u_sharp*2.0);
}
vec3 hsl2rgb(float h,float s,float l){
  float q=l<0.5?l*(1.0+s):l+s-l*s,p2=2.0*l-q;
  float tr=h+1.0/3.0; if(tr>1.0)tr-=1.0;
  float tg=h;
  float tb=h-1.0/3.0; if(tb<0.0)tb+=1.0;
  float r2,g2,b2;
  if(tr<1.0/6.0)r2=p2+(q-p2)*6.0*tr;else if(tr<0.5)r2=q;else if(tr<2.0/3.0)r2=p2+(q-p2)*(2.0/3.0-tr)*6.0;else r2=p2;
  if(tg<1.0/6.0)g2=p2+(q-p2)*6.0*tg;else if(tg<0.5)g2=q;else if(tg<2.0/3.0)g2=p2+(q-p2)*(2.0/3.0-tg)*6.0;else g2=p2;
  if(tb<1.0/6.0)b2=p2+(q-p2)*6.0*tb;else if(tb<0.5)b2=q;else if(tb<2.0/3.0)b2=p2+(q-p2)*(2.0/3.0-tb)*6.0;else b2=p2;
  return vec3(r2,g2,b2);
}
vec3 cmap(float I){
  if(u_cmap<1.5)return vec3(I,I,I);
  if(u_cmap<2.5)return vec3(0.0,I,0.0);
  if(u_cmap<3.5)return vec3(I,0.0,0.0);
  if(u_cmap<4.5)return vec3(0.0,I*0.3,I);
  if(u_cmap<5.5)return hsl2rgb(I*0.75,1.0,0.5);
  if(u_cmap<6.5)return hsl2rgb((1.0-I)*0.75,0.95,0.5);
  if(u_cmap<7.5)return vec3(min(1.0,I*1.8),max(0.0,(I-0.4)*1.6),0.0);
  if(u_cmap<8.5)return vec3(I*60.0/255.0,I*150.0/255.0,min(1.0,I+40.0/255.0));
  return vec3(I,I*190.0/255.0,I*60.0/255.0);
}
void main(){
  vec2 p=gl_FragCoord.xy; p.y=u_res.y-p.y;
  if(isBlocked(p)){gl_FragColor=vec4(0.0,0.0,0.0,1.0);return;}
  float k=TAU/u_wl,om=k;
  if(u_cmap<0.5){
    vec3 col=vec3(0.0);
    ${spectralBody}
    float mx=max(max(col.r,col.g),max(col.b,1.0));
    if(u_gamma!=1.0)col=pow(col/mx,vec3(1.0/u_gamma))*mx;
    col=u_inv>0.5?vec3(1.0)-min(col/mx,vec3(1.0)):min(col,vec3(1.0));
    gl_FragColor=vec4(col,1.0);return;
  }
  float amp=0.0,nAct=0.0;
  ${superBody}
  float N=max(1.0,nAct);
  float I;
  if(u_spos<0.5){
    float r0=0.0,got0=0.0,maxOPD=0.0;
    ${opdBody}
    float Lc=(u_wl/(1.0-u_coh+0.001))*0.5;
    float env=u_coh>=1.0?1.0:exp(-pow(maxOPD/Lc,2.0));
    I=clamp((u_bg+(1.0-u_bg)*(0.5*(1.0-env)+fringeF(amp/N)*env))*u_bright,0.0,1.0);
  } else {
    I=clamp((u_bg+(1.0-u_bg)*fringeF(amp/N))*u_bright,0.0,1.0);
  }
  if(u_gamma!=1.0)I=pow(I,1.0/u_gamma);
  if(u_inv>0.5)I=1.0-I;
  gl_FragColor=vec4(cmap(I),1.0);
}`;
}

function compileShader(gl,type,src){
  const s=gl.createShader(type);gl.shaderSource(s,src);gl.compileShader(s);
  if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)){console.error('Shader error:',gl.getShaderInfoLog(s));return null;}
  return s;
}

let glQuadBuf=null;
function initGL(){
  gl=glCanvas.getContext('webgl',{antialias:false,depth:false,alpha:false});
  if(!gl){console.error('No WebGL');return false;}
  glQuadBuf=gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER,glQuadBuf);
  gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([-1,-1,1,-1,-1,1,1,1]),gl.STATIC_DRAW);
  return true;
}

// Shader recompile is expensive — do it outside the render loop, debounced
let glNeedsRecompile=true;
let glPendingNS=1, glPendingNW=1;
function scheduleRecompile(nSrc,nWall){
  glPendingNS=nSrc; glPendingNW=nWall; glNeedsRecompile=true;
}
function maybeRecompile(){
  if(!glNeedsRecompile)return true;
  glNeedsRecompile=false;
  const NS=Math.max(glPendingNS,1), NW=Math.max(glPendingNW,1);
  const key=NS+'_'+NW;
  if(key===glCompiledKey)return true; // already compiled for these counts
  if(glProg)gl.deleteProgram(glProg);
  glUniforms={};
  const vert=compileShader(gl,gl.VERTEX_SHADER,VERT_SRC);
  const frag=compileShader(gl,gl.FRAGMENT_SHADER,buildFragSrc(NS,NW));
  if(!vert||!frag)return false;
  glProg=gl.createProgram();gl.attachShader(glProg,vert);gl.attachShader(glProg,frag);gl.linkProgram(glProg);
  if(!gl.getProgramParameter(glProg,gl.LINK_STATUS)){console.error('Link error:',gl.getProgramInfoLog(glProg));return false;}
  gl.useProgram(glProg);
  gl.bindBuffer(gl.ARRAY_BUFFER,glQuadBuf);
  const loc=gl.getAttribLocation(glProg,'a_pos');gl.enableVertexAttribArray(loc);gl.vertexAttribPointer(loc,2,gl.FLOAT,false,0,0);
  const unis=['u_res','u_time','u_wl','u_bright','u_bg','u_gamma','u_damp','u_sharp',
              'u_cmap','u_fringe','u_spos','u_inv','u_coh','u_sc'];
  for(const u of unis)glUniforms[u]=gl.getUniformLocation(glProg,u);
  for(let i=0;i<NS;i++){glUniforms['sA'+i]=gl.getUniformLocation(glProg,`u_srcA[${i}]`);glUniforms['sB'+i]=gl.getUniformLocation(glProg,`u_srcB[${i}]`);glUniforms['sC'+i]=gl.getUniformLocation(glProg,`u_srcC[${i}]`);glUniforms['sD'+i]=gl.getUniformLocation(glProg,`u_srcD[${i}]`);}
  for(let i=0;i<NW;i++){glUniforms['wA'+i]=gl.getUniformLocation(glProg,`u_wallA[${i}]`);for(let s=0;s<4;s++)glUniforms['sd'+(i*4+s)]=gl.getUniformLocation(glProg,`u_slitData[${i*4+s}]`);}
  glCompiledKey=key;
  return true;
}

const CMAP_ID={spectral:0,mono:1,laser:2,red:3,blue:4,false:5,spectrum:6,fire:7,ice:8,gold:9};
const FRINGE_ID={sharp:0,cos:1,binary:2,grating:3,gauss:4};
const SUPERPOS_ID={phasor:0,incoherent:1,product:2,max:3};

function renderGL(eSrc){
  if(!gl)return;
  const allSrc=[...eSrc,...huygSrcs];
  const NS=Math.max(allSrc.length,1);
  const NW=Math.max(Math.min(walls.length,MAX_WALLS),1);
  scheduleRecompile(NS,NW);
  if(!maybeRecompile())return;

  const u=glUniforms;
  gl.viewport(0,0,W,H);
  gl.uniform2f(u.u_res,W,H);
  gl.uniform1f(u.u_time,simTime);
  gl.uniform1f(u.u_wl,wavelength);
  gl.uniform1f(u.u_bright,brightness);
  gl.uniform1f(u.u_bg,bgLevel);
  gl.uniform1f(u.u_gamma,gamma);
  gl.uniform1f(u.u_damp,damping);
  gl.uniform1f(u.u_sharp,sharpness);
  gl.uniform1f(u.u_cmap,CMAP_ID[colorMap]??1);
  gl.uniform1f(u.u_fringe,FRINGE_ID[fringeStyle]??0);
  gl.uniform1f(u.u_spos,SUPERPOS_ID[superpos]??0);
  gl.uniform1f(u.u_inv,invertImg?1.0:0.0);
  const ls=getLightSource(eSrc[0]||{lightSrc:'custom'});
  gl.uniform1f(u.u_coh,ls.coh);

  for(let i=0;i<NS;i++){
    const s=allSrc[i];
    if(!s){gl.uniform4f(u['sA'+i],0,0,0,0);gl.uniform4f(u['sB'+i],0,0,0,1);gl.uniform4f(u['sC'+i],0,0,0,0);gl.uniform4f(u['sD'+i],0,0,0,0);continue;}
    const isH=(s.type==='huygen');
    const tp=s.type==='point'?0.0:s.type==='plane'?1.0:2.0;
    const sx=isH||s.type==='point'?s.x:s.cx;
    const sy=isH||s.type==='point'?s.y:s.cy;
    const lsSrc=getLightSource(s);
    const wlPx=lsSrc.id==='custom'?wavelength:lsSrc.wlPx;
    const sideV=s.type==='plane'?(s.side==='left'?1.0:s.side==='right'?-1.0:0.0):0.0;
    const[r,gv,bv]=srcRGB(s);
    const wallIdx=isH?Math.max(0,walls.indexOf(s.wallRef)):0.0;
    gl.uniform4f(u['sA'+i],tp,sx,sy,s.amp);
    gl.uniform4f(u['sB'+i],s.phase*Math.PI/180,(s.angle||0)*Math.PI/180,sideV,wlPx);
    gl.uniform4f(u['sC'+i],r,gv,bv,isH?(s.fwd||1.0):lsSrc.wlNm);
    gl.uniform4f(u['sD'+i],wallIdx,0,0,0);
  }

  const nWallActual=Math.min(walls.length,MAX_WALLS);
  gl.uniform4f(u.u_sc,
    walls[0]?Math.min(walls[0].slits.length,4):0,
    walls[1]?Math.min(walls[1].slits.length,4):0,
    walls[2]?Math.min(walls[2].slits.length,4):0,
    walls[3]?Math.min(walls[3].slits.length,4):0);
  for(let wi=0;wi<NW;wi++){
    const w=walls[wi];
    if(!w){gl.uniform4f(u['wA'+wi],0,0,0,0);for(let s=0;s<4;s++)gl.uniform4f(u['sd'+(wi*4+s)],0,0,0,0);continue;}
    const L=Math.hypot(W,H);
    gl.uniform4f(u['wA'+wi],w.xFrac,w.angle*Math.PI/180,w.thick,w.enabled?1.0:0.0);
    for(let si=0;si<4;si++){
      if(si<w.slits.length){const sl=w.slits[si];gl.uniform4f(u['sd'+(wi*4+si)],sl.pos,(sl.width/2)/L,0,0);}
      else gl.uniform4f(u['sd'+(wi*4+si)],0,0,0,0);
    }
  }
  gl.drawArrays(gl.TRIANGLE_STRIP,0,4);
}

// ─── SNAP ─────────────────────────────────────────────────────
const snap=v=>snapOn?Math.round(v/snapSz)*snapSz:v;

// ─── ANALYSIS ─────────────────────────────────────────────────
function updateAnalysis(eSrc,k,omega){
  document.getElementById('d-n').textContent=String(eSrc.length);
  const ls=getLightSource(eSrc[0]||{lightSrc:'custom'});
  const Lc=ls.coh>=1?'inf':((wavelength/(1-ls.coh+0.001))*0.5).toFixed(1);
  document.getElementById('d-lc').textContent=String(Lc);
  const row=[];for(let x=0;x<W;x+=2)row.push(fieldAt(x,H/2,eSrc,k,omega,simTime));
  const peaks=[];for(let i=1;i<row.length-1;i++)if(row[i]>row[i-1]&&row[i]>row[i+1]&&row[i]>0.5)peaks.push(i*2);
  if(peaks.length>=2){const avg=peaks.slice(1).reduce((s,p,i)=>s+(p-peaks[i]),0)/(peaks.length-1);document.getElementById('d-fs').textContent=avg.toFixed(1);}
  else document.getElementById('d-fs').textContent='-';
  const Mx=Math.max(...row),Mn=Math.min(...row);
  document.getElementById('d-vis').textContent=(Mx+Mn)>0?((Mx-Mn)/(Mx+Mn)).toFixed(3):'-';
  if(curOnCanvas&&eSrc.length>=1){
    const paths=eSrc.map(s=>pathLen(s,curX,curY));const opd=paths.length>=2?Math.abs(paths[0]-paths[1]):null;
    document.getElementById('d-opd').textContent=opd!==null?opd.toFixed(1):'-';
    document.getElementById('d-phi').textContent=opd!==null?((opd/wavelength*360)%360).toFixed(1):'-';
    document.getElementById('d-ord').textContent=opd!==null?(opd/wavelength).toFixed(2):'-';
    document.getElementById('d-I').textContent=fieldAt(curX,curY,eSrc,k,omega,simTime).toFixed(3);
  } else {['d-opd','d-phi','d-ord','d-I'].forEach(id=>document.getElementById(id).textContent='hover canvas');}
}

// ─── MAIN RENDER LOOP ─────────────────────────────────────────
function render(){
  const now=performance.now();const dt=(now-lastFrame)/1000;lastFrame=now;
  fpsEst=fpsEst*0.94+(1/dt)*0.06;document.getElementById('fps').textContent=fpsEst.toFixed(0)+' fps';
  if(!paused&&!frozen)simTime+=dt*speed;
  const k=TAU/wavelength,omega=k;const eSrc=sources.filter(s=>s.enabled);
  buildHuygens(eSrc,k,omega);
  renderGL(eSrc);
  ctx.clearRect(0,0,W,H);
  drawWalls();
  if(showGrid){ctx.save();ctx.strokeStyle='rgba(255,255,255,0.04)';ctx.lineWidth=1;for(let x=0;x<W;x+=snapSz){ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,H);ctx.stroke();}for(let y=0;y<H;y+=snapSz){ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(W,y);ctx.stroke();}ctx.restore();}
  if(showRings){ctx.save();for(const s of eSrc){if(s.type!=='point')continue;const col=srcCSS(s).replace('rgb(','rgba(').replace(')',',0.3)');ctx.strokeStyle=col;ctx.lineWidth=0.5;for(let r=wavelength/2;r<Math.hypot(W,H);r+=wavelength){ctx.beginPath();ctx.arc(s.x,s.y,r,0,TAU);ctx.stroke();}}ctx.restore();}
  if(showNulls&&eSrc.length>=2){for(let y=0;y<H;y+=2)for(let x=0;x<W;x+=2){if(isBlocked(x,y))continue;let s=0;for(const src of [...eSrc,...huygSrcs])s+=srcField(src,x,y,k,omega,simTime);if(Math.abs(s/Math.max(1,eSrc.length+huygSrcs.length))<0.08){ctx.fillStyle='rgba(25,25,25,0.7)';ctx.fillRect(x,y,2,2);}}}
  if(showProfLine)drawScanIndicator();if(showLabels)drawSources();
  if(curOnCanvas){const I=fieldAt(curX,curY,eSrc,k,omega,simTime);document.getElementById('cursor-hud').textContent=`x=${curX.toFixed(0)}  y=${curY.toFixed(0)}  I=${I.toFixed(3)}`;}
  frameCount++;if(frameCount%12===0)updateAnalysis(eSrc,k,omega);
  drawProfile(eSrc,k,omega);requestAnimationFrame(render);
}

// ─── DRAWING — WALLS ──────────────────────────────────────────
function drawWalls(){
  for(let wi=0;wi<walls.length;wi++){
    const w=walls[wi];if(!w.enabled)continue;
    const a=w.angle*Math.PI/180,wx=w.xFrac*W,L=Math.hypot(W,H),lx=-Math.sin(a),ly=Math.cos(a);
    const sel=(wi===selWall&&editWalls);ctx.save();
    ctx.strokeStyle=sel?'rgba(255,170,0,0.9)':'rgba(255,255,255,0.55)';ctx.lineWidth=w.thick;ctx.lineCap='butt';
    const sorted=[...w.slits].sort((a,b)=>a.pos-b.pos);const segs=[];let prev=0;
    for(const sl of sorted){const hw=(sl.width/2)/L;segs.push([prev,sl.pos-hw]);prev=sl.pos+hw;}segs.push([prev,1]);
    for(const[t0,t1]of segs){if(t1<=t0)continue;ctx.beginPath();ctx.moveTo(wx+lx*(t0-0.5)*L,H/2+ly*(t0-0.5)*L);ctx.lineTo(wx+lx*(t1-0.5)*L,H/2+ly*(t1-0.5)*L);ctx.stroke();}
    ctx.lineWidth=1;ctx.strokeStyle='rgba(127,255,0,0.6)';ctx.setLineDash([3,3]);
    for(const sl of sorted){const hw=(sl.width/2)/L;ctx.beginPath();ctx.moveTo(wx+lx*(sl.pos-hw-0.5)*L,H/2+ly*(sl.pos-hw-0.5)*L);ctx.lineTo(wx+lx*(sl.pos+hw-0.5)*L,H/2+ly*(sl.pos+hw-0.5)*L);ctx.stroke();}
    ctx.setLineDash([]);ctx.fillStyle=sel?'#ffaa00':'rgba(255,255,255,0.5)';ctx.font='bold 10px JetBrains Mono';ctx.textAlign='center';ctx.textBaseline='middle';ctx.fillText(w.name,wx+16,H/2);ctx.restore();
  }
}

// ─── DRAWING — SOURCE MARKERS ─────────────────────────────────
function drawSources(){
  for(let i=0;i<sources.length;i++){
    const s=sources[i];if(!s.enabled)continue;const sel=(i===selSrc&&!editWalls),col=srcCSS(s,60);ctx.save();
    if(s.type==='point'){const r=sel?12:7;ctx.shadowColor=col;ctx.shadowBlur=sel?16:7;ctx.strokeStyle=col;ctx.lineWidth=sel?2.5:1.5;ctx.beginPath();ctx.arc(s.x,s.y,r,0,TAU);ctx.stroke();ctx.shadowBlur=0;ctx.fillStyle='rgba(0,0,0,0.85)';ctx.beginPath();ctx.arc(s.x,s.y,r,0,TAU);ctx.fill();ctx.fillStyle=col;ctx.font=`bold ${sel?11:9}px JetBrains Mono`;ctx.textAlign='center';ctx.textBaseline='middle';ctx.fillText(s.name,s.x,s.y);}
    else{const a=s.angle*Math.PI/180,lx=-Math.sin(a),ly=Math.cos(a),nx=Math.cos(a),ny=Math.sin(a),L=Math.hypot(W,H);ctx.shadowColor=col;ctx.shadowBlur=sel?10:4;ctx.strokeStyle=col;ctx.lineWidth=sel?2.5:1.5;ctx.beginPath();ctx.moveTo(s.cx-lx*L,s.cy-ly*L);ctx.lineTo(s.cx+lx*L,s.cy+ly*L);ctx.stroke();ctx.shadowBlur=0;ctx.strokeStyle=col.replace('rgb(','rgba(').replace(')',',0.6)');ctx.lineWidth=1;ctx.setLineDash([5,5]);const arrow=(ax,ay,dx,dy)=>{ctx.beginPath();ctx.moveTo(s.cx,s.cy);ctx.lineTo(ax,ay);ctx.moveTo(ax,ay);ctx.lineTo(ax-dx*8+lx*5,ay-dy*8+ly*5);ctx.moveTo(ax,ay);ctx.lineTo(ax-dx*8-lx*5,ay-dy*8-ly*5);ctx.stroke();};if(s.side==='right'||s.side==='both')arrow(s.cx+nx*35,s.cy+ny*35,nx,ny);if(s.side==='left'||s.side==='both')arrow(s.cx-nx*35,s.cy-ny*35,-nx,-ny);ctx.setLineDash([]);ctx.fillStyle=col;ctx.font=`bold ${sel?11:9}px JetBrains Mono`;ctx.textAlign='center';ctx.textBaseline='middle';ctx.fillText(s.name,s.cx+ny*20,s.cy-nx*20);}
    ctx.restore();
  }
}

// ─── PROFILE STRIP ────────────────────────────────────────────
const PCSS={cyan:'rgba(0,229,255,0.5)',green:'rgba(127,255,0,0.5)',white:'rgba(255,255,255,0.35)',red:'rgba(255,61,127,0.5)'};
const PHEX={cyan:'#00e5ff',green:'#7fff00',white:'#ffffff',red:'#ff3d7f'};
function scanLine(){const L=Math.hypot(W,H);switch(profMode){case 'horiz':return[0,H*profPos,W,H*profPos];case 'vert':return[W*profPos,0,W*profPos,H];case 'diag':{const a=profPos*Math.PI;return[W/2-Math.cos(a)*L,H/2-Math.sin(a)*L,W/2+Math.cos(a)*L,H/2+Math.sin(a)*L];}case 'radial':{const a=profPos*TAU;return[W/2,H/2,W/2+Math.cos(a)*L,H/2+Math.sin(a)*L];}default:return null;}}
function drawScanIndicator(){ctx.save();ctx.strokeStyle=PCSS[profColor]||PCSS.cyan;ctx.lineWidth=1;ctx.setLineDash([4,4]);if(profMode==='circ'){const r=Math.min(W,H)*(0.1+profPos*0.4);ctx.beginPath();ctx.arc(W/2,H/2,r,0,TAU);ctx.stroke();}else{const ln=scanLine();if(ln){ctx.beginPath();ctx.moveTo(ln[0],ln[1]);ctx.lineTo(ln[2],ln[3]);ctx.stroke();}}ctx.restore();}
function drawProfile(eSrc,k,omega){
  pctx.fillStyle='#000';pctx.fillRect(0,0,PW,PH);
  if(showProfGrid){const mg=PH*0.08,sp=PH*0.84;[0,0.25,0.5,0.75,1].forEach(lv=>{const y=PH-mg-lv*sp;pctx.strokeStyle=lv===0||lv===1?'rgba(255,255,255,0.2)':lv===0.5?'rgba(255,255,255,0.12)':'rgba(255,255,255,0.06)';pctx.lineWidth=1;pctx.beginPath();pctx.moveTo(0,y);pctx.lineTo(PW,y);pctx.stroke();pctx.fillStyle='rgba(255,255,255,0.2)';pctx.font='7px JetBrains Mono';pctx.textAlign='left';pctx.textBaseline='middle';pctx.fillText(lv===1?'1':lv===0?'0':lv.toFixed(2),2,y);});}
  const N=PW,vals=new Float32Array(N);
  const smpl=(x,y)=>{let I=fieldAt(x,y,eSrc,k,omega,simTime);if(gamma!==1)I=Math.pow(I,1/gamma);return invertImg?1-I:I;};
  if(profMode==='circ'){const r=Math.min(W,H)*(0.1+profPos*0.4);for(let i=0;i<N;i++){const a=(i/N)*TAU;vals[i]=smpl(W/2+Math.cos(a)*r,H/2+Math.sin(a)*r);}}
  else if(profMode==='radial'){const a=profPos*TAU,mxR=Math.hypot(W,H)/2;for(let i=0;i<N;i++){const d=(i/(N-1))*mxR;vals[i]=smpl(W/2+Math.cos(a)*d,H/2+Math.sin(a)*d);}}
  else{const ln=scanLine();if(!ln)return;const[x0,y0,x1,y1]=ln;for(let i=0;i<N;i++){const t=i/(N-1);vals[i]=smpl(x0+(x1-x0)*t,y0+(y1-y0)*t);}}
  const col=PHEX[profColor]||'#00e5ff',mg=PH*0.08,sp=PH*0.84;
  if(showProfFill){pctx.save();const gr=pctx.createLinearGradient(0,0,0,PH);gr.addColorStop(0,col+'88');gr.addColorStop(1,col+'0a');pctx.fillStyle=gr;pctx.beginPath();pctx.moveTo(0,PH);for(let i=0;i<N;i++)pctx.lineTo(i,PH-mg-vals[i]*sp);pctx.lineTo(N-1,PH);pctx.closePath();pctx.fill();pctx.restore();}
  pctx.save();pctx.strokeStyle=col;pctx.lineWidth=1.5;pctx.lineJoin='round';pctx.shadowColor=col;pctx.shadowBlur=3;pctx.beginPath();for(let i=0;i<N;i++){const py=PH-mg-vals[i]*sp;i===0?pctx.moveTo(0,py):pctx.lineTo(i,py);}pctx.stroke();pctx.restore();
  if(!showProfGrid){pctx.fillStyle='rgba(255,255,255,0.18)';pctx.font='7px JetBrains Mono';pctx.textBaseline='top';pctx.textAlign='left';pctx.fillText('1',2,PH*0.08-1);pctx.textBaseline='bottom';pctx.fillText('0',2,PH-1);}
  const modeLabel={horiz:'H-slice',vert:'V-slice',diag:'Diagonal',radial:'Radial',circ:'Circular'};
  pctx.fillStyle='rgba(255,255,255,0.18)';pctx.font='7px JetBrains Mono';pctx.textAlign='right';pctx.textBaseline='bottom';pctx.fillText(modeLabel[profMode],PW-3,PH-1);
  document.getElementById('plabel').textContent=profMode==='circ'?`r=${(Math.min(W,H)*(0.1+profPos*0.4)).toFixed(0)}px`:profMode==='radial'?`th=${(profPos*360).toFixed(0)}deg`:profMode==='diag'?`th=${(profPos*180).toFixed(0)}deg`:`pos=${(profPos*100).toFixed(0)}%`;
}

// ─── RESIZE ───────────────────────────────────────────────────
function resize(){
  const cw=document.getElementById('cwrap');W=cw.clientWidth;H=cw.clientHeight;
  glCanvas.width=W;glCanvas.height=H;canvas.width=W;canvas.height=H;
  const pw=document.getElementById('pwrap');PW=pcanvas.width=pw.clientWidth;PH=pcanvas.height=pw.clientHeight;
}

// ─── DYNAMIC UI ───────────────────────────────────────────────
function rebuildSrcUI(){
  const tabs=document.getElementById('src-tabs');tabs.innerHTML='';
  sources.forEach((s,i)=>{const col=srcCSS(s,40);const t=document.createElement('div');t.className='itab'+(i===selSrc&&!editWalls?' on':'')+(s.enabled?'':' off');t.textContent=s.name+(s.type==='plane'?' ->':'');t.style.borderColor=col;if(i===selSrc&&!editWalls)t.style.background=col;t.addEventListener('click',()=>{selSrc=i;editWalls=false;rebuildSrcUI();rebuildWallUI();});tabs.appendChild(t);});
  const ctrl=document.getElementById('src-ctrl');ctrl.innerHTML='';
  if(!sources.length){ctrl.innerHTML='<div style="font-size:8px;color:var(--dim)">No sources - use + Point or + Plane.</div>';rebuildWallUI();return;}
  if(editWalls){rebuildWallUI();return;}
  const s=sources[selSrc];if(!s){rebuildWallUI();return;}
  mkTogRow(ctrl,s,'enabled','Enabled',rebuildSrcUI);
  {const ls=getLightSource(s);const row=document.createElement('div');row.className='row';const lbl=el('span','lbl','Light src');const sw=document.createElement('div');sw.className='swatch';setSwatchColor(sw,s);const sel=document.createElement('select');LIGHT_SOURCES.forEach(ls=>{const o=document.createElement('option');o.value=ls.id;o.textContent=ls.name;if(s.lightSrc===ls.id)o.selected=true;sel.appendChild(o);});sel.addEventListener('change',()=>{s.lightSrc=sel.value;const nls=getLightSource(s);setSwatchColor(sw,s);if(s.lightSrc!=='custom'){wavelength=nls.wlPx;const sl2=document.getElementById('sl-wl');if(sl2){sl2.value=wavelength;document.getElementById('vl-wl').textContent=wavelength+'px';}}desc.textContent=nls.desc+` coh: ${(nls.coh*100).toFixed(0)}%`;rebuildSrcUI();});row.append(lbl,sw,sel);ctrl.appendChild(row);const desc=document.createElement('div');desc.style.cssText='font-size:8px;color:var(--dim);margin:0 0 2px 62px;line-height:1.4;';desc.textContent=ls.desc+` coh: ${(ls.coh*100).toFixed(0)}%`;ctrl.appendChild(desc);}
  mkSelRow(ctrl,s,'waveform','Waveform',['sine','square','saw','tri']);
  mkSlRow(ctrl,s,'amp','Amplitude',0.1,3,0.05,v=>v.toFixed(2));
  mkSlRow(ctrl,s,'phase','Phase deg',0,360,1,v=>v.toFixed(0)+'deg');
  if(s.type==='point'){mkSlRow(ctrl,s,'x','X',0,W||600,1,v=>v.toFixed(0));mkSlRow(ctrl,s,'y','Y',0,H||400,1,v=>v.toFixed(0));}
  else{mkSlRow(ctrl,s,'cx','Centre X',0,W||600,1,v=>v.toFixed(0));mkSlRow(ctrl,s,'cy','Centre Y',0,H||400,1,v=>v.toFixed(0));mkSlRow(ctrl,s,'angle','Angle deg',0,360,1,v=>v.toFixed(0)+'deg');mkSelRow(ctrl,s,'side','Side',['right','left','both'],{right:'Right only',left:'Left only',both:'Both sides'});}
  const rm=document.createElement('button');rm.className='btn danger';rm.style.marginTop='3px';rm.textContent='Remove '+s.name;rm.addEventListener('click',()=>{sources.splice(selSrc,1);selSrc=Math.min(selSrc,sources.length-1);rebuildSrcUI();});ctrl.appendChild(rm);
  rebuildWallUI();
}
function setSwatchColor(swatch,src){const[r,g,b]=srcRGB(src);swatch.style.background=`rgb(${Math.min(255,(r*255+40))|0},${Math.min(255,(g*255+40))|0},${Math.min(255,(b*255+40))|0})`;}

function rebuildWallUI(){
  const tabs=document.getElementById('wall-tabs');tabs.innerHTML='';
  if(!walls.length){tabs.innerHTML='<div style="font-size:8px;color:var(--dim)">No walls - use + Wall.</div>';document.getElementById('wall-ctrl').innerHTML='';return;}
  walls.forEach((w,i)=>{const t=document.createElement('div');t.className='itab'+(i===selWall&&editWalls?' on':'');t.textContent=w.name+(w.enabled?'':' x');t.style.borderColor='rgba(255,170,0,0.5)';if(i===selWall&&editWalls)t.style.background='rgba(255,170,0,0.8)';t.addEventListener('click',()=>{selWall=i;editWalls=true;rebuildSrcUI();});tabs.appendChild(t);});
  const ctrl=document.getElementById('wall-ctrl');ctrl.innerHTML='';if(!editWalls)return;
  const w=walls[selWall];if(!w)return;
  mkTogRow(ctrl,w,'enabled','Enabled',rebuildWallUI);mkSlRow(ctrl,w,'xFrac','H position',0,1,0.005,v=>(v*100).toFixed(0)+'%');mkSlRow(ctrl,w,'angle','Angle deg',-45,45,1,v=>v.toFixed(0)+'deg');mkSlRow(ctrl,w,'thick','Thickness',2,20,1,v=>v.toFixed(0)+'px');
  const hdr=document.createElement('div');hdr.style.cssText='display:flex;align-items:center;gap:6px;margin-top:3px;font-size:8px;color:var(--dim);';hdr.innerHTML=`<span>SLITS (${w.slits.length})</span>`;const addBtn=document.createElement('button');addBtn.className='btn';addBtn.style.fontSize='8px';addBtn.textContent='+ Slit';addBtn.addEventListener('click',()=>{w.slits.push({pos:0.5,width:20});rebuildWallUI();});hdr.appendChild(addBtn);ctrl.appendChild(hdr);
  w.slits.forEach((sl,si)=>{const card=document.createElement('div');card.className='slit-card';const ch=document.createElement('div');ch.className='slit-card-hdr';ch.innerHTML=`<span style="font-size:8px;color:var(--green)">Slit ${si+1}</span>`;const rm=document.createElement('button');rm.className='btn danger';rm.style.fontSize='8px';rm.textContent='x';rm.addEventListener('click',()=>{w.slits.splice(si,1);rebuildWallUI();});ch.appendChild(rm);card.appendChild(ch);mkSlRow(card,sl,'pos','Position',0,1,0.005,v=>(v*100).toFixed(0)+'%');mkSlRow(card,sl,'width','Width px',4,120,1,v=>v.toFixed(0)+'px');ctrl.appendChild(card);});
  const rm=document.createElement('button');rm.className='btn danger';rm.style.marginTop='3px';rm.textContent='Remove '+w.name;rm.addEventListener('click',()=>{walls.splice(selWall,1);selWall=Math.max(0,selWall-1);if(!walls.length)editWalls=false;rebuildSrcUI();});ctrl.appendChild(rm);
}

const el=(tag,cls,txt)=>{const e=document.createElement(tag);if(cls)e.className=cls;if(txt!==undefined)e.textContent=txt;return e;};
function mkSlRow(parent,obj,key,label,mn,mx,step,fmt){const row=document.createElement('div');row.className='row';const lbl=el('span','lbl',label);const sl=document.createElement('input');sl.type='range';sl.min=mn;sl.max=mx;sl.step=step;sl.value=obj[key];const vl=el('span','val',fmt(obj[key]));sl.addEventListener('input',()=>{obj[key]=parseFloat(sl.value);vl.textContent=fmt(obj[key]);});row.append(lbl,sl,vl);parent.appendChild(row);}
function mkSelRow(parent,obj,key,label,opts,labelMap={}){const row=document.createElement('div');row.className='row';row.appendChild(el('span','lbl',label));const sel=document.createElement('select');opts.forEach(o=>{const op=el('option');op.value=o;op.textContent=labelMap[o]||o;if(obj[key]===o)op.selected=true;sel.appendChild(op);});sel.addEventListener('change',()=>{obj[key]=sel.value;});row.appendChild(sel);parent.appendChild(row);}
function mkTogRow(parent,obj,key,label,cb){const row=document.createElement('div');row.className='row';const b=el('button','tog'+(obj[key]?' on':''),label+' '+(obj[key]?'ON':'OFF'));b.addEventListener('click',()=>{obj[key]=!obj[key];b.className='tog'+(obj[key]?' on':'');b.textContent=label+' '+(obj[key]?'ON':'OFF');if(cb)cb();});row.appendChild(b);parent.appendChild(row);}

function bindSlider(id,setter,fmt){const sl=document.getElementById(id),vl=document.getElementById(id.replace('sl-','vl-'));if(sl)sl.addEventListener('input',()=>{setter(parseFloat(sl.value));if(vl)vl.textContent=fmt(parseFloat(sl.value));});}
function bindSelect(id,setter){const e=document.getElementById(id);if(e)e.addEventListener('change',()=>setter(e.value));}
function bindToggle(id,getter,setter,cb){const e=document.getElementById(id);if(e)e.addEventListener('click',()=>{setter(!getter());e.classList.toggle('on',getter());if(cb)cb();});}

bindSlider('sl-sharp',v=>sharpness=v,v=>v.toFixed(1));
bindSlider('sl-wl',v=>wavelength=v,v=>v.toFixed(0)+'px');
bindSlider('sl-bright',v=>brightness=v,v=>v.toFixed(2));
bindSlider('sl-bg',v=>bgLevel=v,v=>v.toFixed(2));
bindSlider('sl-gamma',v=>gamma=v,v=>v.toFixed(2));
bindSlider('sl-speed',v=>speed=v,v=>v.toFixed(2));
bindSlider('sl-damp',v=>damping=v,v=>v.toFixed(3));
bindSlider('sl-snap',v=>snapSz=v,v=>v.toFixed(0)+'px');
bindSlider('sl-ppos',v=>profPos=v,v=>{const m={horiz:`${(v*100).toFixed(0)}%`,vert:`${(v*100).toFixed(0)}%`,diag:`${(v*180).toFixed(0)}deg`,radial:`${(v*360).toFixed(0)}deg`,circ:`r=${(Math.min(W,H)*(0.1+v*0.4)).toFixed(0)}px`};return m[profMode]||`${(v*100).toFixed(0)}%`;});
bindSelect('sel-cmap',v=>colorMap=v);bindSelect('sel-style',v=>fringeStyle=v);bindSelect('sel-mode',v=>superpos=v);bindSelect('sel-pcol',v=>profColor=v);
bindToggle('t-snap',()=>snapOn,v=>snapOn=v);bindToggle('t-labels',()=>showLabels,v=>showLabels=v);bindToggle('t-grid',()=>showGrid,v=>showGrid=v);
bindToggle('t-rings',()=>showRings,v=>showRings=v);bindToggle('t-nodes',()=>showNulls,v=>showNulls=v);bindToggle('t-invert',()=>invertImg,v=>invertImg=v);
bindToggle('t-pline',()=>showProfLine,v=>showProfLine=v);bindToggle('t-pfill',()=>showProfFill,v=>showProfFill=v);bindToggle('t-pgrid',()=>showProfGrid,v=>showProfGrid=v);

document.getElementById('b-pause').addEventListener('click',()=>{paused=!paused;const b=document.getElementById('b-pause');b.textContent=paused?'Play':'Pause';b.classList.toggle('on',paused);});
document.getElementById('b-freeze').addEventListener('click',()=>{frozen=!frozen;document.getElementById('b-freeze').classList.toggle('on',frozen);});
document.getElementById('b-addpt').addEventListener('click',()=>{if(sources.length>=6)return;const i=sources.length;sources.push(mkPoint(snap(W*0.3+Math.random()*W*0.4),snap(H*0.3+Math.random()*H*0.4),i));selSrc=sources.length-1;editWalls=false;rebuildSrcUI();});
document.getElementById('b-addpw').addEventListener('click',()=>{if(sources.length>=6)return;sources.push(mkPlane(sources.length));selSrc=sources.length-1;editWalls=false;rebuildSrcUI();});
document.getElementById('b-addwall').addEventListener('click',()=>{walls.push(mkWall());selWall=walls.length-1;editWalls=true;rebuildSrcUI();});
document.getElementById('b-clear').addEventListener('click',()=>{sources=[];walls=[];selSrc=0;selWall=0;editWalls=false;rebuildSrcUI();});
document.querySelectorAll('#tab-bar .tab').forEach(tab=>{tab.addEventListener('click',()=>{document.querySelectorAll('#tab-bar .tab').forEach(t=>t.classList.remove('on'));document.querySelectorAll('.tpane').forEach(p=>p.classList.remove('on'));tab.classList.add('on');document.getElementById('pane-'+tab.dataset.t).classList.add('on');});});
document.querySelectorAll('#prof-modes [data-m]').forEach(btn=>{btn.addEventListener('click',()=>{document.querySelectorAll('#prof-modes [data-m]').forEach(b=>b.classList.remove('on'));btn.classList.add('on');profMode=btn.dataset.m;});});

// ─── PRESETS ──────────────────────────────────────────────────
const PRESETS=[
  {name:"Young's slits",fn(){walls=[mkWall()];walls[0].xFrac=0.5;walls[0].slits=[{pos:0.38,width:16},{pos:0.62,width:16}];const pw=mkPlane(0);pw.angle=0;pw.side='right';pw.cx=W*0.08;pw.cy=H*0.5;sources=[pw];selSrc=0;selWall=0;editWalls=false;rebuildSrcUI();}},
  {name:"Single slit",fn(){walls=[mkWall()];walls[0].xFrac=0.5;walls[0].slits=[{pos:0.5,width:30}];const pw=mkPlane(0);pw.angle=0;pw.side='right';pw.cx=W*0.08;pw.cy=H*0.5;sources=[pw];selSrc=0;editWalls=false;rebuildSrcUI();}},
  {name:"Triple slit",fn(){walls=[mkWall()];walls[0].xFrac=0.5;walls[0].slits=[{pos:0.32,width:14},{pos:0.5,width:14},{pos:0.68,width:14}];const pw=mkPlane(0);pw.angle=0;pw.side='right';pw.cx=W*0.08;pw.cy=H*0.5;sources=[pw];selSrc=0;editWalls=false;rebuildSrcUI();}},
  {name:"2 Point sources",fn(){walls=[];sources=[mkPoint(W*0.5,H*0.35,0),mkPoint(W*0.5,H*0.65,1)];selSrc=0;editWalls=false;rebuildSrcUI();}},
  {name:"Michelson rings",fn(){walls=[];sources=[mkPoint(W*0.5+2,H*0.5+2,0),mkPoint(W*0.5-2,H*0.5-2,1)];selSrc=0;editWalls=false;rebuildSrcUI();}},
  {name:"Red + Green",fn(){walls=[];const a=mkPoint(W*0.4,H*0.5,0);a.lightSrc='laser_red';const b=mkPoint(W*0.6,H*0.5,1);b.lightSrc='laser_green';sources=[a,b];wavelength=70;const sl=document.getElementById('sl-wl');if(sl){sl.value=70;document.getElementById('vl-wl').textContent='70px';}colorMap='spectral';const cm=document.getElementById('sel-cmap');if(cm)cm.value='spectral';selSrc=0;editWalls=false;rebuildSrcUI();}},
  {name:"Vortex 6",fn(){walls=[];sources=[];const r=Math.min(W,H)*0.18;for(let i=0;i<6;i++){const a=i/6*TAU;const s=mkPoint(W/2+Math.cos(a)*r,H/2+Math.sin(a)*r,i);s.phase=i*60;sources.push(s);}selSrc=0;editWalls=false;rebuildSrcUI();}},
  {name:"2 Plane waves",fn(){walls=[];const a=mkPlane(0);a.angle=20;a.cx=W*0.5;a.cy=H*0.5;a.side='both';const b=mkPlane(1);b.angle=160;b.cx=W*0.5;b.cy=H*0.5;b.side='both';sources=[a,b];selSrc=0;editWalls=false;rebuildSrcUI();}},
];
(()=>{const grid=document.getElementById('pgrid');PRESETS.forEach(p=>{const b=document.createElement('button');b.className='btn';b.textContent=p.name;b.addEventListener('click',p.fn);grid.appendChild(b);});})();

// ─── CANVAS INTERACTION ───────────────────────────────────────
let dragging=false,dragSrc=-1,dragWall=-1,offX=0,offY=0;
function canvasXY(e){const rect=canvas.getBoundingClientRect(),sx=W/rect.width,sy=H/rect.height;const pt=e.touches?e.touches[0]:e;return{x:(pt.clientX-rect.left)*sx,y:(pt.clientY-rect.top)*sy};}
function nearestSource(x,y,radius=26){for(let i=0;i<sources.length;i++){const s=sources[i],sx=s.type==='point'?s.x:s.cx,sy=s.type==='point'?s.y:s.cy;if(Math.hypot(sx-x,sy-y)<radius)return i;}return -1;}
function nearestWall(x){for(let i=0;i<walls.length;i++)if(Math.abs(walls[i].xFrac*W-x)<18)return i;return -1;}
canvas.addEventListener('mousemove',e=>{const r=canvas.getBoundingClientRect();curX=(e.clientX-r.left)*(W/r.width);curY=(e.clientY-r.top)*(H/r.height);curOnCanvas=true;});
canvas.addEventListener('mouseleave',()=>{curOnCanvas=false;document.getElementById('cursor-hud').textContent='move mouse over pattern';});
canvas.addEventListener('touchmove',e=>{const r=canvas.getBoundingClientRect();curX=(e.touches[0].clientX-r.left)*(W/r.width);curY=(e.touches[0].clientY-r.top)*(H/r.height);curOnCanvas=true;},{passive:true});
canvas.addEventListener('pointerdown',e=>{e.preventDefault();const{x,y}=canvasXY(e);const nw=nearestWall(x);if(editWalls&&nw>=0){dragging=true;dragWall=nw;dragSrc=-1;selWall=nw;rebuildWallUI();return;}const ns=nearestSource(x,y);if(ns>=0){dragging=true;dragSrc=ns;dragWall=-1;selSrc=ns;editWalls=false;const s=sources[ns];offX=x-(s.type==='point'?s.x:s.cx);offY=y-(s.type==='point'?s.y:s.cy);rebuildSrcUI();return;}if(!editWalls&&sources.length>0){const s=sources[selSrc];if(s.type==='point'){s.x=snap(x);s.y=snap(y);}else{s.cx=snap(x);s.cy=snap(y);}rebuildSrcUI();}else if(editWalls&&walls.length>0){walls[selWall].xFrac=Math.max(0,Math.min(1,x/W));rebuildWallUI();}});
canvas.addEventListener('pointermove',e=>{e.preventDefault();if(!dragging)return;const{x,y}=canvasXY(e);if(dragWall>=0&&dragWall<walls.length){walls[dragWall].xFrac=Math.max(0,Math.min(1,x/W));rebuildWallUI();return;}if(dragSrc>=0&&dragSrc<sources.length){const s=sources[dragSrc];if(s.type==='point'){s.x=snap(x-offX);s.y=snap(y-offY);}else{s.cx=snap(x-offX);s.cy=snap(y-offY);}rebuildSrcUI();}});
canvas.addEventListener('pointerup',()=>{dragging=false;dragSrc=-1;dragWall=-1;});
canvas.addEventListener('pointercancel',()=>{dragging=false;dragSrc=-1;dragWall=-1;});

// ─── INIT ─────────────────────────────────────────────────────
window.addEventListener('resize',()=>{resize();rebuildSrcUI();});
resize();
if(!initGL()){const banner=document.createElement('div');banner.style.cssText='position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:#ff3d7f;font-size:14px;text-align:center;';banner.textContent='WebGL not available. Try Chrome or Firefox.';document.getElementById('cwrap').appendChild(banner);}
PRESETS[0].fn();
render();
</script>
</body>
</html>
